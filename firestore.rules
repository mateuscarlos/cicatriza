rules_version = '2';

/**
 * Firestore Security Rules — CICATRIZA
 * Escopo por usuário (ownerId) + ACL por paciente (roles: owner|editor|viewer).
 * Validações críticas nos writes de Wounds/Assessments.
 *
 * Observação: Regras não conseguem validar datas relativas ao "agora" com precisão.
 * Validar lógicas avançadas (ex.: nextReview > hoje) no App/Cloud Functions.
 */

service cloud.firestore {
  match /databases/{db}/documents {

    // =========================
    // Helpers (funções comuns)
    // =========================
    function isAuth() {
      return request.auth != null;
    }

    function isOwnerDoc(res) {
      return res.data.ownerId == request.auth.uid;
    }

    // Recupera doc do paciente para verificar ACL herdada
    function patientDoc(pid) {
      return get(/databases/$(database)/documents/patients/$(pid));
    }

    // Retorna role do usuário no paciente (ou string vazia)
    function myRoleOnPatient(pid) {
      return patientDoc(pid).data.acl.roles[request.auth.uid];
    }

    function hasViewer(pid) {
      return myRoleOnPatient(pid) in ['owner', 'editor', 'viewer'];
    }

    function hasEditor(pid) {
      return myRoleOnPatient(pid) in ['owner', 'editor'];
    }

    function hasOwner(pid) {
      return myRoleOnPatient(pid) == 'owner';
    }

    // Validadores numéricos simples
    function numberBetween(n, min, max) {
      return n is int || n is float
        && n >= min && n <= max;
    }

    function optNumberBetween(obj, field, min, max) {
      return !(field in obj) || numberBetween(obj[field], min, max);
    }

    // Soma de percentuais (granulation + epithelial + slough + necrotic == 100)
    function validTissueSum(tissuePct) {
      return
        ('granulation' in tissuePct) && ('epithelial' in tissuePct) &&
        ('slough' in tissuePct) && ('necrotic' in tissuePct) &&
        (tissuePct.granulation + tissuePct.epithelial + tissuePct.slough + tissuePct.necrotic) == 100 &&
        numberBetween(tissuePct.granulation, 0, 100) &&
        numberBetween(tissuePct.epithelial, 0, 100) &&
        numberBetween(tissuePct.slough, 0, 100) &&
        numberBetween(tissuePct.necrotic, 0, 100);
    }

    // Validação de "sizeMm" = { length, width, depth }
    function validSizeMm(sizeMm) {
      return ('length' in sizeMm) && ('width' in sizeMm) && ('depth' in sizeMm) &&
             numberBetween(sizeMm.length, 0, 1000) &&
             numberBetween(sizeMm.width, 0, 1000) &&
             numberBetween(sizeMm.depth, 0, 200);
    }

    // Valida enum por string
    function inEnum(val, allowed) {
      return val is string && allowed.hasAny([val]);
    }

    // =========================
    // Validação de documentos
    // =========================

    // Wound
    function validateWound(newData) {
      // Campos mínimos
      return
        ('ownerId' in newData) &&
        ('patientId' in newData) &&
        ('type' in newData) &&
        ('sizeMm' in newData) &&
        ('painLevel' in newData) &&

        // Tipos/intervalos
        inEnum(newData.type, ['ulcera_venosa','lpp','queimadura','cirurgica','outros']) &&
        validSizeMm(newData.sizeMm) &&
        numberBetween(newData.painLevel, 0, 10) &&

        // Campos opcionais com intervalos razoáveis
        !( 'onsetDuration' in newData ) ||
          (
            ('value' in newData.onsetDuration) &&
            ('unit' in newData.onsetDuration) &&
            numberBetween(newData.onsetDuration.value, 0, 3650) &&
            inEnum(newData.onsetDuration.unit, ['days','weeks','months'])
          ) &&

        !( 'status' in newData ) || inEnum(newData.status, ['na','melhorando','estagnada','piorando']) &&

        // Localização (opcional mas, se presente, deve ser coerente)
        !( 'location' in newData ) ||
          (
            ('bodyMapZone' in newData.location) &&
            optNumberBetween(newData.location, 'x', 0, 1) &&
            optNumberBetween(newData.location, 'y', 0, 1)
          );
    }

    // Assessment
    function validateAssessment(newData) {
      return
        // Campos obrigatórios mínimos
        ('ownerId' in newData) &&
        ('patientId' in newData) &&
        ('woundId' in newData) &&
        ('date' in newData) && // formato validado no app
        ('woundBed' in newData) &&
        ('woundEdge' in newData) &&
        ('periwoundSkin' in newData) &&
        ('sizeMm' in newData) &&
        ('painLevel' in newData) &&
        ('woundStatus' in newData) &&

        // sizeMm + painLevel
        validSizeMm(newData.sizeMm) &&
        numberBetween(newData.painLevel, 0, 10) &&

        // woundStatus enum
        inEnum(newData.woundStatus, ['primeira_avaliacao','piorando','estagnada','melhorando','na']) &&

        // woundBed.tissuePct soma == 100
        ('tissuePct' in newData.woundBed) &&
        validTissueSum(newData.woundBed.tissuePct) &&

        // woundBed.exudate
        ('exudate' in newData.woundBed) &&
        ('level' in newData.woundBed.exudate) &&
        inEnum(newData.woundBed.exudate.level, ['dry','low','medium','high']) &&
        !( 'type' in newData.woundBed.exudate ) ||
           inEnum(newData.woundBed.exudate.type, ['clear','cloudy','purulent','pink_red','thick','thin']) &&

        // woundBed.infection (se hasInfection true, permitir lista de sinais)
        !( 'infection' in newData.woundBed ) ||
          (
            ('hasInfection' in newData.woundBed.infection) &&
            ( newData.woundBed.infection.hasInfection is bool ) &&
            ( !( 'signs' in newData.woundBed.infection ) ||
              ( newData.woundBed.infection.signs.size() <= 12 ) // limite razoável
            )
          ) &&

        // managementGoals (opcional; se existir, validar valores)
        !( 'managementGoals' in newData ) ||
          (
            newData.managementGoals is list &&
            newData.managementGoals.size() <= 10 &&
            // cada item precisa estar no enum
            newData.managementGoals.hasOnly(['remove_nonviable','manage_exudate','manage_bacterial_load','rehydrate_bed','protect_gran_epith','protect_periwound'])
          ) &&

        // treatmentChoice (se presente, exigir dressingType e rationale)
        !( 'treatmentChoice' in newData ) ||
          (
            ('dressingType' in newData.treatmentChoice) &&
            ('rationale' in newData.treatmentChoice)
          ) &&

        // attachmentsCount (se presente)
        !( 'attachmentsCount' in newData ) ||
          numberBetween(newData.attachmentsCount, 0, 50);
    }

    // =========================
    // USERS
    // =========================
    match /users/{uid} {
      allow read, write: if isAuth() && uid == request.auth.uid;
    }

    // =========================
    // PATIENTS (root)
    // =========================
    match /patients/{pid} {
      // Criar: usuário autenticado e ownerId == auth.uid
      allow create: if isAuth() &&
        request.resource.data.ownerId == request.auth.uid &&
        ('acl' in request.resource.data) &&
        ( 'roles' in request.resource.data.acl ) &&
        ( request.resource.data.acl.roles[request.auth.uid] == 'owner' );

      // Ler: owner ou quem tem role (viewer/editor/owner)
      allow read: if isAuth() &&
        ( isOwnerDoc(resource) || hasViewer(pid) );

      // Atualizar/Excluir: owner ou editor
      allow update, delete: if isAuth() &&
        ( isOwnerDoc(resource) || hasEditor(pid) );

      // ==============
      // WOUNDS
      // ==============
      match /wounds/{wid} {
        // Ler: viewer+
        allow read: if isAuth() && ( isOwnerDoc(patientDoc(pid)) || hasViewer(pid) );

        // Criar/Atualizar/Excluir: editor+
        allow create: if isAuth() &&
          hasEditor(pid) &&
          validateWound(request.resource.data) &&
          // ownerId deve ser do autor da operação
          request.resource.data.ownerId == request.auth.uid &&
          // vínculo correto ao paciente
          request.resource.data.patientId == pid;

        allow update: if isAuth() &&
          hasEditor(pid) &&
          validateWound(request.resource.data) &&
          // ownerId e patientId não podem mudar para outro
          request.resource.data.ownerId == resource.data.ownerId &&
          request.resource.data.patientId == pid;

        allow delete: if isAuth() && hasEditor(pid);

        // ============
        // ASSESSMENTS
        // ============
        match /assessments/{aid} {
          // Ler: viewer+
          allow read: if isAuth() && ( isOwnerDoc(patientDoc(pid)) || hasViewer(pid) );

          // Criar/Atualizar: editor+ com validações
          allow create: if isAuth() &&
            hasEditor(pid) &&
            validateAssessment(request.resource.data) &&
            request.resource.data.ownerId == request.auth.uid &&
            request.resource.data.patientId == pid &&
            request.resource.data.woundId == wid;

          allow update: if isAuth() &&
            hasEditor(pid) &&
            validateAssessment(request.resource.data) &&
            // ownerId/patientId/woundId não mudam
            request.resource.data.ownerId == resource.data.ownerId &&
            request.resource.data.patientId == pid &&
            request.resource.data.woundId == wid;

          allow delete: if isAuth() && hasEditor(pid);
        }

        // =====
        // MEDIA
        // =====
        match /media/{mid} {
          // Ler: viewer+
          allow read: if isAuth() && ( isOwnerDoc(patientDoc(pid)) || hasViewer(pid) );

          // Criar/Atualizar/Excluir: editor+
          allow create: if isAuth() &&
            hasEditor(pid) &&
            // ownerId e vínculos corretos
            request.resource.data.ownerId == request.auth.uid &&
            request.resource.data.patientId == pid &&
            request.resource.data.woundId == wid &&
            // campos mínimos
            ('type' in request.resource.data) &&
            inEnum(request.resource.data.type, ['image','video']) &&
            ('storagePath' in request.resource.data);

          allow update: if isAuth() &&
            hasEditor(pid) &&
            request.resource.data.ownerId == resource.data.ownerId &&
            request.resource.data.patientId == pid &&
            request.resource.data.woundId == wid;

          allow delete: if isAuth() && hasEditor(pid);
        }
      }
    }

    // =========================
    // APPOINTMENTS
    // =========================
    match /appointments/{id} {
      allow read, create: if isAuth() &&
        request.resource.data.ownerId == request.auth.uid;

      allow update, delete: if isAuth() &&
        isOwnerDoc(resource);
    }

    // =========================
    // TRANSFERS
    // =========================
    match /transfers/{id} {
      // Criar: qualquer auth; validações detalhadas no App/Functions
      allow create: if isAuth();

      // Ler/Atualizar: somente envolvidos (fromUserId ou toUserId)
      allow read, update: if isAuth() &&
        (request.auth.uid in [resource.data.fromUserId, resource.data.toUserId]);

      // Exclusão: apenas quem criou (fromUserId)
      allow delete: if isAuth() &&
        request.auth.uid == resource.data.fromUserId;
    }

    // =========================
    // (Opcional) AUDIT EVENTS
    // =========================
    match /auditEvents/{eid} {
      // Somente o ator ou o dono do recurso auditado (recomendado ajustar conforme necessidade)
      allow read: if isAuth() && (
        request.auth.uid == resource.data.actorId ||
        request.auth.uid == resource.data.ownerId
      );
      allow create: if isAuth(); // criado por Functions
      allow update, delete: if false; // imutável
    }
  }
}
